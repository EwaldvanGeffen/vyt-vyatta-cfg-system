#!/bin/bash
#
# Module: install-system
# 
# **** License ****
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# This code was originally developed by Vyatta, Inc.
# Portions created by Vyatta are Copyright (C) 2006, 2007 Vyatta, Inc.
# All Rights Reserved.
# 
# Author: Robert Bays
# Date: 2006
# Description:
# 
# **** End License ****
#
# Vyatta system installer script.
#
#
# If you set VYATTA_AUTO_INSTALL I will try to do an automated install for you

if [ -e /etc/default/vyatta ] ; then
    . /etc/default/vyatta
fi

: ${vyatta_prefix:=/opt/vyatta}
: ${vyatta_exec_prefix:=$vyatta_prefix}
: ${vyatta_bindir:=${vyatta_exec_prefix}/bin}
: ${vyatta_sbindir:=${vyatta_exec_prefix}/sbin}
: ${vyatta_sysconfdir:=${vyatta_prefix}/etc}

ofrconfdir=${vyatta_sysconfdir}/config
fdconfdir=/media/floppy/config
rootfsdir=/mnt/rootfs

# By default this is not a union install
# UNION=false

# install log file name
INSTALL_LOG="install.log"
# root partition minimum size in MB
ROOT_MIN="450"
# the base install drive e.g. sda
if [ -n "$INSTALL_DRIVE" ]; then
  INSTALL_DRIVE=""
fi
# the install partition e.g. sda1
if [ -n "$ROOT_PARTITION" ]; then
  ROOT_PARTITION=""
fi
# the config partition e.g. sda2
if [ -n "$CONFIG_PARTITION" ]; then
  CONFIG_PARTITION=""
fi
# the size of the root partition
if [ -n "$ROOT_PARTITION_SIZE" ]; then
  ROOT_PARTITION_SIZE=""
fi
# global holding variable used in the select_partition sub
PARTITION=''

# Process ID of this script for the lame marketing spinner
SPID=$$

# Path to standalone root password reset script
PWRESET=/opt/vyatta/sbin/standalone_root_pw_reset

# Grub options
GRUB_OPTIONS="quiet"

# Output to both console (last device is /dev/console)
VTY_CONSOLE="console=ttyS0,9600 console=tty0"
SERIAL_CONSOLE="console=tty0 console=ttyS0,9600"

# If VGA_LOGO is set, enable use of the VGA monitor for displaying the
# logo during boot.  The "vga=" boot command specifies a VGA mode that
# is encoded as shown below.  We pick a value that is likely to work
# on most systems:
#
# Color depth      | 640x480 | 800x600 | 1024x768 | 1280x1024
# -----------------+---------+---------+----------+----------
# 256 (8bit)       |   769       771       773        775
# 32000 (15bit)    |   784       787       790        793
# 65000 (16bit)    |   785       788       791        794
# 16.7 Mill.(24bit)|   786       789       792        795
#
VGA_LOGO="vga=788"

# trap signals so we can kill runaway progress indicators
trap 'progress_indicator stop; exit 1' 1
trap 'progress_indicator stop; exit 1' 2

# turn off any mounted swap partitions
turnoffswap () {
  if [ -f "/proc/swaps" ]; then
    myresponse=$(cat /proc/swaps)
    if [ -n "$myresponse" ]; then
      echo "turning off swaps..." >> $INSTALL_LOG
      swapoff -a
    fi
  fi
}

# Validates a user response.  Returns the response if valid.
# Returns the default is the user just hits enter.  
# Returns nothing if not valid.  Default parameter is $1.
# Options are in $2.  If options are defined return must be a member
# of the enum. 
get_response () {
  ldefault=$(echo "$1" | tr [:upper:] [:lower:])
  loptions=$(echo "$2" | tr [:upper:] [:lower:])

  # get the response from the user
  read myresponse
  myresponse=$(echo "$myresponse" | tr [:upper:] [:lower:])

  # Check to see if the user accepts the default
  if [ -z "$myresponse" ]; then
    echo -n $ldefault
  # if we are passing in options to check, make sure response is a valid option
  elif [ -n "$loptions" ]; then
    for token in $loptions
      do
        if [ "$token" == "$myresponse" ]; then
          echo -n "$myresponse"
          return 0
        fi
      done
    return 1
  else
    echo -n "$myresponse"
  fi

  return 0
}

# Return the size of the drive in MB
get_drive_size () {
  ldrive=$1

  # Make sure you can print disk info using parted
  parted /dev/$ldrive p >/dev/null 2>&1

  # If unable to read disk, it's likely it needs a disklabel
  if [  "$?" != "0" ]; then
    echo "Creating a new disklabel on $ldrive" >> $INSTALL_LOG
    echo "parted /dev/$ldrive mklabel msdos" >> $INSTALL_LOG
    output=$(parted /dev/$ldrive mklabel msdos)

    # Get the drive size from parted
    lsize=$(parted /dev/$ldrive p | grep "^Disk" | awk '{ print $3 }')

    if [ $(echo $lsize | grep error) ]; then
      echo "Unable to read disk label.  Exiting."
      exit 1
    fi
  fi

  # Get the drive size from parted
  lsize=$(parted /dev/$ldrive p | grep "^Disk" | awk '{ print $3 }')
  # Get the reported units (mB, GB, kB)
  lmodifier=$(echo $lsize | sed 's/[0-9\.]//g')
  # remove the modifier
  lsize=$(echo $lsize | sed 's/[a-z,A-Z]//g')
  # Remove any fractions
  lsize=$(echo $lsize | cut -f1 -d'.')
  # Translate our size into mB if not there already
  if [ $lmodifier = "GB" ]; then 
    lsize=$(($lsize * 1000))
  elif [ $lmodifier = "kB" ]; then 
    lsize=$(($lsize / 1000))
  fi

  echo $lsize
}


# Probe hardrives not shown in /proc/partitions by default
probe_drives () {
  # find IDE drives.  Not all drives show up in /proc/partitions for
  # some reason.
  # TODO: not sure we have to do this for anything but compact flash
  # when we test on other platforms, we will find out and modify this section
  # as appropriate
  drive=$(find /proc/ide/ide* -name "hd*" 2>/dev/null | /usr/bin/awk -F"/" '{ print $5 }')

  # now exclude all drives but disks
  for drive in $drive
  do
    media=$(cat /proc/ide/$drive/media)
    if [ "$media" = "disk" ]; then
     output=$(mount | grep $drive)
      if [ -z "$output" ]; then
        output=$(parted /dev/$DRIVE p)
      fi
    fi
  done
}


warn_of_dire_consequences () {
  # Give the user a requisite warning that we are about to nuke their drive
  response=''
  while [ -z $response ]
  do
    echo "This will destroy all data on /dev/$INSTALL_DRIVE."
    echo -n "Continue? (Yes/No) [No]: "
    response=$(get_response "No" "Yes No Y N")

    if [ "$response" == "no" ] || [ "$response" == "n" ]; then
      echo "Ok then.  Exiting..."
      exit 1
    fi
  done
}



check_for_old_raid () {
    # First, trigger construction of previously configured RAID groups
    echo -n "Looking for pre-existing RAID groups..."
    raid_config=`mdadm --examine --scan`
    if [ -z "$raid_config" ]; then
	echo "none found."
	return
    fi

    echo "found some."
    echo "Trying to configure pre-existing RAID groups..."
    mdadm --assemble --scan --auto=yes --symlink=no

    # Identify physical drives
    raid_drives=$(cat /proc/partitions | awk '{ if ($4!="name") { print $4 } }' | grep "md" | egrep -v "^$")

    if [ -z "$raid_drives" ]; then
	echo "Unable to configure any RAID groups."
	return
    fi

    numraids=`echo $raid_drives | wc -w`

    if [ $numraids -eq 1 ]; then
	echo "The following RAID group is now configured:"
    else
	echo "The following RAID groups are now configured:"
    fi

    for drive in $raid_drives
    do
	cat /proc/mdstat | grep --after-context 2 ^$drive | sed -e 's/^/\t/'
    done

    if [ $numraids -eq 1 ]; then
	echo -n "Would you like to use this one? (Yes/No) [Yes]:"
    else
	echo -n "Would you like to use one of these? (Yes/No) [Yes]:"
    fi

    response=$(get_response "Yes" "Yes No Y N")
    if [ "$response" == "no" ] || [ "$response" == "n" ]; then
	echo "Ok.  Not using existing RAID groups."
	echo "Stopping existing RAID groups:"
	mdadm --stop --scan
	return
    fi

    if [ $numraids -eq 1 ]; then
	INSTALL_DRIVE=$raid_drives
    else
	# take the first drive as the default
	INSTALL_DRIVE=$(echo $raid_drives | /usr/bin/awk '{ print $1 }')
    	echo -n "Which one would you like to use? ($raid_drives) [$INSTALL_DRIVE]: "
	INSTALL_DRIVE=$(get_response "$INSTALL_DRIVE" "$drives")
    fi

    echo "Using RAID partition $INSTALL_DRIVE"

    warn_of_dire_consequences

    ROOT_PARTITION=$INSTALL_DRIVE

    # make sure we aren't working on a mounted part
    unmount "$INSTALL_DRIVE"

    # check for an old config on the partition
    check_config_partition "$ROOT_PARTITION"

    # create the ext3 fs on the part
    make_filesystem "$ROOT_PARTITION"

    INSTALL_METHOD=RAID
}

check_for_new_raid () {
    # Identify physical drives
    drives=$(cat /proc/partitions | awk '{ if ($4!="name") { print $4 } }' | egrep -v "[0-9]$" | egrep -v "^$")

    numdrives=`echo $drives | wc -w`

    # Need at least two drives for RAID-1.  We don't yet have the code
    # to handle selection of two from a set of 3 or more, so for now, we
    # only support two drives.
    #
    if [ $numdrives -ne 2 ]; then
	return
    fi

    drive1=`echo $drives | awk '{ print $1 }'`
    drive2=`echo $drives | awk '{ print $2 }'`

    drivesize1=$(get_drive_size $drive1)
    drivesize2=$(get_drive_size $drive2)

    # Both drives must have enough space to hold our minimum root filesystem
    #
    if [ $drivesize1 -lt $ROOT_MIN -o $drivesize2 -lt $ROOT_MIN ]; then
	return
    fi


    echo "You have two disk drives:"
    echo -e "\t$drive1 \t$drivesize1 MB"
    echo -e "\t$drive2 \t$drivesize2 MB"

    echo -n "Would you like to configure RAID-1 mirroring on them? (Yes/No) [Yes]:"
    response=$(get_response "Yes" "Yes No Y N")
    if [ "$response" == "no" ] || [ "$response" == "n" ]; then
	echo "Ok.  Not configuring RAID-1."
	return
    fi

    if [ $drivesize1 -ne $drivesize2 ]; then
	echo "Since the disks are not the same size, we will use the smaller"
	echo "of the two sizes in configuring the RAID-1 set.  This will"
	echo "waste some space on the larger drive."
	echo ""
    fi

    # Configure RAID-1
    echo "This process will erase all data on both drives."
    echo -n "Are you sure you want to do this? (Yes/No) [No]: "
    response=$(get_response "Yes" "Yes No Y N")
    if [ "$response" == "no" ] || [ "$response" == "n" ]; then
	echo "Ok.  Not configuring RAID-1."
	return
    fi
    
    for drive in $drives
    do
	echo "Deleting old partitions on drive $drive"
	# remove any existing partitions on that drive
	delete_partitions "$drive"
    done

    # Need to leave space on both disks between the MBR and the start
    # of the first partition for grub.  Grub needs to embed a large
    # boot image there when booting off RAID devices.
    #
    # Partition creation variables are in units of megabytes.
    part_start_offset=2
    part_diag_size=60

    if [ $drivesize1 -gt $drivesize2 ]; then
	size=$drivesize1
    else
	size=$drivesize2
    fi

    let min_size_with_diag=${MIN_ROOT}+${part_diag_size}
    if [ $size -ge $min_size_with_diag ]; then
	echo "Would you like me to create a $part_diag_size MB partition for diagnostics?"
	echo -n "(Yes/No) [No]: "
	diag_response=$(get_response "No" "Yes No Y N")
	if [ "$diag_response" == "yes" ] || [ "$diag_response" == "y" ]; then
	    for drive in $drives
	    do
		echo "Creating diag partition on drive $drive"
		create_partitions "$drive" $part_diag_size $part_start_offset "no"
		sfdisk --change-id /dev/$drive 1 0x6
	    done
	    data_dev=2
	    let part_start_offset+=$part_diag_size
	else
	    data_dev=1
	fi
    fi

    let size-=$part_start_offset

    for drive in $drives
    do
	echo "Creating data partition: /dev/${drive}${data_dev}"
	create_partitions "$drive" $size $part_start_offset "no"
	sfdisk --change-id /dev/$drive $data_dev 0xfd
    done

    # Must give partition device time to settle
    sleep 5
    echo

    for drive in $drives
    do
	echo "Erasing any previous RAID metadata that may exist on /dev/${drive}${data_dev}"
	mdadm --zero-superblock /dev/${drive}${data_dev}
    done

    echo "Creating RAID-1 group on partitions: /dev/${drive1}${data_dev} /dev/${drive2}${data_dev}"

    raid_dev=md0
    mdadm --create /dev/$raid_dev --level=1 --raid-disks=2 /dev/${drive1}${data_dev} /dev/${drive2}${data_dev}

    if [ $? = 0 -a -e /dev/$raid_dev ]; then
	echo "RAID-1 group created successfully:"
	cat /proc/mdstat | grep --after-context 2 ^$raid_dev | sed -e 's/^/\t/'
    else
	echo "Unable to create RAID-1 group!"
	return
    fi

    INSTALL_DRIVE=$raid_dev
    ROOT_PARTITION=$INSTALL_DRIVE

    # Give device time to settle...
    sleep 5

    # create the ext3 fs on the part
    make_filesystem "$ROOT_PARTITION"

    INSTALL_METHOD=RAID
}


# Takes an argument to display text before choice
# Sets INSTALL_DRIVE.  Note that select_drive should be wrapped 
# in the verification loop, not the included get_response.
select_drive () {
  # list the drives in /proc/partitions.  Remove partitions and empty lines.
  # the first grep pattern looks for devices named c0d0, hda, and sda.
  drives=$(cat /proc/partitions | awk '{ if ($4!="name") { print $4 } }' | egrep "c[0-9]d[0-9]$|[hs]d[a-z]$" | egrep -v "^$")

  # take the first drive as the default
  INSTALL_DRIVE=$(echo $drives | /usr/bin/awk '{ print $1 }')

  # Add the drive sizes to the display to help the user decide
  display=''
  for drive in $drives
  do
    size=$(get_drive_size $drive)
    display="$display $drive\t$size"MB"\n"
  done

  while true
  do
	# Display the drives and ask the user which one to install to
	echo -e "$display"
	echo
	echo -n "$1 [$INSTALL_DRIVE]:"
	response=$(get_response "$INSTALL_DRIVE" "$drives") && break
  done
  INSTALL_DRIVE="$response"

  echo

  # Assume no dma if the disk is smaller than 10G (such as a CF drive)
  size=$(get_drive_size $INSTALL_DRIVE)
  if [[ $size -lt 11000 && ! $GRUB_OPTIONS =~ 'ide=nodma' ]]
  then
      GRUB_OPTIONS="$GRUB_OPTIONS ide=nodma"
  fi
}

# Allow the user to select a partition to work with
# sets the global PARTITION
# $1 is the text to display before prompt
select_partition () {
  minsize=$1
  text=$2
  exclude=$3

  echo -n "Looking for appropriate partitions:  "
  progress_indicator start

  # initialize out global var.  using globals in this way is bad form.  I know.
  PARTITION=''

  # list only the partitions in /proc/partitions.
  parts=$(cat /proc/partitions | awk '{ if ($4!="name") { print $4 " "} }' | egrep "[0-9]" | egrep -v "loop" | tr -d '\n')

  # remove any partitions we have already previously used
  if [ -n "$exclude" ]; then
    for part in $parts; 
    do
      temp=$(echo $part | egrep -v $exclude)
      parts_temp="$parts_temp $temp"
    done
    parts=$parts_temp
  fi

  # Get the partition sizes for display
  # only show linux partitions that have sizes, i.e. remove loops
  display=''
  myparts=''
  for part in $parts
  do
    if [ ${part:0:2} = "md" ]; then
      parttype="RAID"
    else
      rootdev=$(echo $part | sed 's/[0-9]//g')
      parttype=$(fdisk -l /dev/$rootdev | grep $part | grep Linux)
    fi
    if [ -n "$parttype" ]; then
      lsize=$(get_drive_size $part)
      if [ "$lsize" -a $lsize -ge $minsize ]; then
        display="$display $part\t\t$lsize"MB"\n"
        myparts="$myparts $part"
      fi
    fi
  done

  progress_indicator stop
  echo "OK"

  if [ -n "$myparts" ]; then
    lpartition=''
    while [ -z "$lpartition" ]
    do
      # take the first partition as the default
      lpartition=$(echo $myparts | /usr/bin/awk '{ print $1 }')

      echo "I found the following partitions suitable for the Vyatta image:"
      echo -e "Partition\tSize"
      echo -e "$display"
      echo
      echo -n "$text [$lpartition]: "

      lpartition=$(get_response "$lpartition" "$myparts")
      echo
    done
  else
    echo "No suitable partition sizes found.  Exiting..."  | tee $INSTALL_LOG
    exit 1
  fi
  PARTITION=$lpartition
}

rename_old_config() {
  files=$(find /mnt/config -mindepth 1 -type f | grep -v pre-glendale)
  for f in $files; do
    if grep -q '/\*XORP Configuration File, v1.0\*/' $f >&/dev/null; then
      CURTIME=$(date +%F-%H%M%S)
      mv $f $f.pre-glendale.$CURTIME
    fi
  done
}

## check_config_partition
# look to see if this partition contains a config file
# and back it up
check_config_partition() {
  lpart=$1

  # Cleanup from possible partial last run
  rm -fr /mnt/config

  # Look to see if this is a config partition
  mkdir -p /mnt/tmp
  output=$(mount /dev/$lpart /mnt/tmp 2>&1)
  if [ $? != 0 ]; then
    echo -e "Cannot mount /dev/$lpart"."\nmount /dev/$ldrive$part /mnt/tmp\nExiting..." >> $INSTALL_LOG
    echo "$output" >> $INSTALL_LOG
  else
    # Look to see if there is a config partition there
    if [ -f /mnt/tmp/opt/vyatta/etc/config/.vyatta_config ] || [ -f /mnt/tmp/.vyatta_config ]; then
      response=''
      while [ -z "$response" ]
      do
        echo "/dev/$lpart has an old configuration directory!"
        echo -ne "Would you like me to save the data on it\nbefore I delete it? (Yes/No) [Yes]: "
        response=$(get_response "Yes" "Yes No Y N")
        if [ "$response" == "yes" ] || [ "$response" == "y" ]; then
          mkdir -p /mnt/config
          if [ -d /mnt/tmp/opt/vyatta/etc/config ]; then
            output=$(cp -pR /mnt/tmp/opt/vyatta/etc/config/* /mnt/config)
          else
            output=$(cp -pR /mnt/tmp/* /mnt/config)
          fi
          if [ -n "$output" ]; then
            echo -e "Warning: error in copying the old config partition.\nSee $INSTALL_LOG for more details."
            echo -e "Warning: error in copying the old config partition.\ncp -pR /mnt/tmp/* /mnt/config\n$output\n" >> $INSTALL_LOG
          fi
          rename_old_config
        fi
      done
    fi
    umount /mnt/tmp
  fi
}

# Delete all existing partitions for an automated install
# $1 is the drive to delete partitions from
delete_partitions () {
  ldrive=$1

  # get the partitions on the drive
  # in the first grep below we add the optional [p] in order to accomdate cciss drives
  partitions=$(cat /proc/partitions | grep $ldrive[p]*[0-9] | awk '{ print $4 }' | sed 's/\(.*\)\([0-9]$\)/\2/g' | grep -v "^$")

  # now for each part, blow it away
  for part in $partitions
  do
    # Look to see if this is a config partition
    check_config_partition "$ldrive$part"

    echo "Removing partition $part on /dev/$ldrive" >> $INSTALL_LOG
    output=$(parted /dev/$ldrive rm $part)
    status=$?
    if [ "$status" != 0 ]; then
      echo -e "Warning: cannot delete partition $part on $ldrive.\nPlease see $INSTALL_LOG for more details."
      echo -e "Warning: cannot delete partition $part on $ldrive.\nparted /dev/$ldrive rm $part\n$output" >> $INSTALL_LOG
    fi

    # We add a bogus sleep here because the loop needs to wait for udev
    sleep 5
  done
}

# make a filesystem on the drive
# $1 is the drive to format
make_filesystem () {
  ldrive=$1

  echo -n "Creating filesystem on /dev/$ldrive:  "
  echo "Creating filesystem on /dev/$ldrive..." >> $INSTALL_LOG

  progress_indicator start
  output=$(mke2fs -j /dev/$ldrive 2>&1)
  status=$?
  if [ "$status" != 0 ]; then
    echo -e "Error: couldn't create the root filesystem.\nSee $INSTALL_LOG for further details.\nExiting..."
    echo -e "Error: couldn't create the root filesystem.\n/sbin/mke2fs -j /dev/$ldrive\n$output"
    exit 1
  fi
  progress_indicator stop
  echo "OK"
}

# create the root partition
# $1 is the install drive e.g. sda
# $2 is the partition size e.g. 512
# This will set the global ROOT_PARTITION
create_partitions() {
  ldrive=$1
  root_part_size=$2
  start_offset=$3
  initialize_fs=$4

  # Make sure there is enough space on drive
  size=$(get_drive_size "$ldrive") 
  if [ "$root_part_size" -gt "$size" ]; then
    echo "Error: $ldrive is only $size"MB" large."
    exit 1
  fi

  echo "Creating root partition on /dev/$ldrive" >> $INSTALL_LOG
  
  # make the root partition
  output=$(parted /dev/$ldrive mkpart primary $start_offset $root_part_size)
  status=$?
  if [ "$status" != 0 ]; then
    echo -e "Error creating primary partition on $ldrive.\nPlease see $INSTALL_LOG for more details.\nExiting..."
    echo -e "Error creating primary partition on $ldrive.\nparted /dev/$ldrive mkpart primary 0 $root_part_size\n$output" >> $INSTALL_LOG
    exit 1
  fi

  # set the partition number on the device.
  if [ -n "$( echo $ldrive | grep cciss )" ]; then
    # if this is a cciss
    ROOT_PARTITION=$ldrive"p1"
  else
    # else... the rest of the world
    ROOT_PARTITION=$ldrive"1"
  fi
  # udev takes time to re-add the device file, so wait for it
  while [ ! -b "/dev/$ROOT_PARTITION" ] 
  do 
    sleep 1
  done

  if [ "$initialize_fs" = "yes" ]; then
    # make the root and config ext3 file systems.
    make_filesystem "$ROOT_PARTITION"
  fi
}

# Install the root filesystem
# $1 is the partition to install on
install_root_filesystem () {
  ldrive=$1
  version=$(egrep -i version /opt/vyatta/etc/version | awk '{ print $3 }')

  dpkg="/usr/bin/dpkg --force-all --root=$rootfsdir"
  echo "Mounting /dev/$ldrive "
  echo "Mounting /dev/$ldrive..." >> $INSTALL_LOG

  # make the mount point
  output=$(/bin/mkdir -p $rootfsdir)

  # mount the partition
  output=$(mount -t ext3 /dev/$ldrive $rootfsdir)
  status=$?
  
  if [ "$status" != 0 ]; then
    echo -e "Error trying to mount the new root partition.\nPlease see $INSTALL_LOG for details.\nExiting..."
    echo -e "Error trying to mount the new root partition.\nmount -t ext3 /dev/$ldrive $rootfsdir\n$output" >> $INSTALL_LOG
    exit 1
  fi
  
  if [ -z $UNION ]; then
    echo -n "Copying system image files to /dev/$ROOT_PARTITION: "
    progress_indicator start
    # Mount the squashfs for copying
    output=$(mkdir -p /mnt/squashfs)
    if [ -f /live/image/live/filesystem.squashfs ]; then
      output=$(mount /live/image/live/filesystem.squashfs /mnt/squashfs -t squashfs -o loop)
      status=$?
    elif [ -f /live/image/boot/$version/$version.squashfs ]; then
      output=$(mount /live/image/boot/$version/$version.squashfs /mnt/squashfs -t squashfs -o loop)
      status=$?
    else
      echo -e "Error: Unable to find a squash image. \nExiting..."
    fi
  
    if [ "$status" != 0 ]; then
      echo -e "Error trying to mount the squashfs.\nPlease see install log for more details.\nExiting..."
      echo -e "Error trying to mount the squashfs.\nmount /live/image/live/filesystem.squashfs /mnt/squashfs -t squashfs -o loop\n$output" >> $INSTALL_LOG
      exit 1
    fi

    output=$(cp -pR /mnt/squashfs/* $rootfsdir/)
    status=$?
  
    if [ "$status" != 0 ]; then
      echo -e "Error trying to copy the rootfs.\nPlease see install log for more details.\nExiting..."
      echo -e "Error trying to copy the rootfs.\ncp -pR /mnt/squashfs/* $rootfsdir/\n$output" >> $INSTALL_LOG
      exit 1
    fi

    # unmount the squashfs.  No big deal if it fails.
    output=$(umount /mnt/squashfs)

    # create the fstab
    local rootdev="/dev/$ROOT_PARTITION";
    uuid=$(dumpe2fs -h $rootdev 2>/dev/null | awk '/^Filesystem UUID/ {print $3}')
    if [ -z "$uuid" ]
    then
        echo "Unable to read filesystem UUID.  Exiting."
        exit 1
    else
      echo -e "UUID=$uuid\t/\text3\tdefaults\t0 1" >> $rootfsdir/etc/fstab
    fi

    #setup the hostname file
    cp /etc/hostname $rootfsdir/etc/
    cp /etc/hosts $rootfsdir/etc/

    progress_indicator stop
    echo "OK"
  else
    mkdir -p $rootfsdir/boot/$version
    if [ -f /live/image/live/filesystem.squashfs ]; then
      echo Copying squashfs image...
      cp /live/image/live/filesystem.squashfs $rootfsdir/boot/$version/$version.squashfs
      echo Copying kernel and initrd images...
      cp -ar /boot/initrd.img-* $rootfsdir/boot/$version/
      cp -ar /boot/vmlinuz-* $rootfsdir/boot/$version/
    else
      echo Copying image files...
      cp -ar /live/image/boot/$version $rootfsdir/boot/
    fi
  fi
}

# copy the configuration to the config partition
# $1 is the config partition device
copy_config () {
  config_partition=$1
  lerror=''
  config_default=$vyatta_sysconfdir/config.boot.default
  tmp_config_default=/tmp/${vyatta_sysconfdir//\//__}

  # create the config directory on the union file system
  mkdir -p $rootfsdir$ofrconfdir

  # create the proper perms on the new config partition
  chgrp vyattacfg $rootfsdir$ofrconfdir
  chmod 775 $rootfsdir$ofrconfdir

  # create our config partition marker
  touch $rootfsdir$ofrconfdir/.vyatta_config

  if [ -d /mnt/config ]; then
    echo "Copying old configurations to config partition."
    cp -pR /mnt/config/* $rootfsdir$ofrconfdir
  else
    # Find the config files and give the user the option to copy config files
    # TODO: this needs cleaned up
    if [ -f $ofrconfdir/config.boot ]; then
	config=$ofrconfdir/config.boot
    fi
    if [ -f $fdconfdir/config.boot ]; then
      if [ -z "$config" ]; then
        config="$fdconfdir/config.boot"
      else
        config="$config $fdconfdir/config.boot"
      fi
    fi

    if [ -n "$config" ]; then
      echo "I found the following configuration files"
      for file in $config
      do 
        echo $file
      done

      default=$(echo -e $config | awk '{ print $1 }')

      while [ -z "$configfile" ]
      do
        echo -n "Which one should I copy to $INSTALL_DRIVE? [$default]: "
        configfile=$(get_response "$default" "$config")
      done
      
      echo
      output=$(cp $configfile $rootfsdir$ofrconfdir)
      if [ -n "$output" ]; then
        echo "Error copying file $configfile to config directory.  Exiting..." >> $INSTALL_LOG
        exit 1
      fi
    fi
  fi

  # set the permissions on the new config file
  if [ -f $rootfsdir$ofrconfdir/config.boot ]; then
    chgrp vyattacfg $rootfsdir$ofrconfdir/config.boot
    chmod 775 $rootfsdir$ofrconfdir/config.boot
  fi
}

set_encrypted_password() {
    sed -i \
       -e "/ user $1 {/,/}/s/encrypted-password .*\$/encrypted-password \"$2\"/" $3
}

change_password() {
    local user=$1
    local pwd1="1"
    local pwd2="2"

    until [ "$pwd1" == "$pwd2" ]
    do
        read -p "Enter $user password:" -r -s pwd1 <>/dev/tty 2>&0
	echo
	read -p "Retype $user password:" -r -s pwd2 <>/dev/tty 2>&0
	echo

	if [ "$pwd1" != "$pwd2" ]
	then echo "Passwords do not match"
	fi
    done

    # escape any slashes in resulting password
    local epwd=$(mkpasswd -H md5 "$pwd1" | sed 's:/:\\/:g')
    set_encrypted_password $user $epwd  $rootfsdir$ofrconfdir/config.boot
}

system_setup () {
    echo -n "Would you like to set the passwords for system users (Yes/No) [Yes]: "
    local response=$(get_response "Yes" "Yes No Y N")

    if [ "$response" == "yes" ] || [ "$response" == "y" ]; then
	change_password root
	change_password vyatta
    fi
}


# setup grub on the boot sector of a user queried drive
install_grub () {
  # we now use INSTALL_DRIVE to reference the grub boot drive.
  #  that way I can re-use select_drive.  I'm lazy that way.

  if [ ${INSTALL_DRIVE:0:2} != "md" ]; then
    INSTALL_DRIVE=''
  fi

  mkdir -p $rootfsdir/boot/grub
  # Let the user choose the boot sector
  
  while [ -z "$INSTALL_DRIVE" ]
  do
    echo "I need to install the GRUB boot loader."
    echo "I found the following drives on your system:"
    select_drive "Which drive should GRUB modify the boot partition on?"
  done

  echo -n "Setting up grub:  "
  echo "Setting up grub..." >> $INSTALL_LOG

  # Install grub in the boot sector of the primary drive
  progress_indicator start
  grub-install --no-floppy --recheck --root-directory=$rootfsdir /dev/$INSTALL_DRIVE >>$INSTALL_LOG 2>&1
  progress_indicator stop

  # Assume no dma if the disk is smaller than 10G (such as a CF drive)
  size=$(get_drive_size $INSTALL_DRIVE)
  if [[ $size -lt 11000 && ! $grub_options =~ 'ide=nodma' ]]
  then
     grub_options="ide=nodma"
  fi

  # Check if using aufs
  if grep -q aufs /proc/filesystems
  then
      if [ -z "$grub_options" ]
      then
	  grub_options="union=aufs"
      else
	  grub_options="$grub_options union=aufs"
      fi
  fi

  # if union install tell vyatta-grub-setup
  if [ ! -z $UNION ]; then
    version=$(egrep -i version /opt/vyatta/etc/version | awk '{ print $3 }')
    grub_args="-u $version"
  fi
  if /opt/vyatta/sbin/vyatta-grub-setup $grub_args "$ROOT_PARTITION" "$grub_options" /mnt/rootfs >>$INSTALL_LOG
  then
    echo "OK"
  else
    echo Grub failed to install!
    exit 1
  fi
}

# ask for user input on the parted and skip setup methods
# $1 is whether or not to run parted
# sets globals INSTALL_DRIVE, ROOT_PARTITION, CONFIG_PARTITION
setup_method_manual() {
  parted=$1

  echo "The Vyatta install needs a minimum ${ROOT_MIN}MB root"
  echo "with partiton type 83 (Linux)."
  echo -e "\n\n"

  # if this is parted, let the user create the partitions
  if [ "$INSTALL_METHOD" == "parted" ] || [ "$INSTALL_METHOD" == "p" ]; then
    while [ -z "$INSTALL_DRIVE" ]
    do
      # TODO: right now we only run parted on a single drive
      echo -e "\nI found the following drives on your system:"
      select_drive "Which drive would you like to run parted on?"

    done

    # Unmount the install drive if it is mounted
    unmount "$INSTALL_DRIVE"

    # Run parted and let the user configure
    parted /dev/$INSTALL_DRIVE
  fi

  # Ask for the root partition and make sure it's valid
  while [ -z "$ROOT_PARTITION" ]
  do
    select_partition 500 "Which partition should I install the root on?"
    # Note that PARTITION is defined in select partition
    ROOT_PARTITION=$PARTITION
    unmount "$ROOT_PARTITION"
    vd=$(grep $ROOT_PARTITION /proc/partitions | awk '{ print $4 }')

    if [ -z "$vd" ]; then
      echo
      echo "$ROOT_PARTITION is an invalid partition. Please try again."
      ROOT_PARTITION=""
    fi
  done

  # check for an old config on the partition
  check_config_partition "$ROOT_PARTITION"

  # create the ext3 fs on the part
  make_filesystem "$ROOT_PARTITION"

  # We need to set the INSTALL_DRIVE if it wasn't set when the user ran parted
  # We assume that we will use the boot sector of the same drive that the 
  # partition is on.
  # TODO: Allow different drives to function as the boot device
  if [ -z "$INSTALL_DRIVE" ]; then
    if [ ${ROOT_PARTITION:0:2} = "md" ]; then
        INSTALL_DRIVE=$ROOT_PARTITION
    else
        INSTALL_DRIVE=$(echo $ROOT_PARTITION | sed 's/[0-9]//g')
    fi
  fi
}

# Walk the user through the auto setup method
# sets globals INSTALL_DRIVE, ROOT_PARTITION, CONFIG_PARTITION
setup_method_auto() {
  while [ -z "$INSTALL_DRIVE" ]
  do
    echo "I found the following drives on your system:"
    select_drive "Install the image on?"

    # check to make sure the drive is large enough to hold the image
    if [ -n "$INSTALL_DRIVE" ]; then 
      lsize=$(get_drive_size "$INSTALL_DRIVE")
      total=$ROOT_MIN
      if [ "$total" -gt "$lsize" ]; then
        echo "Unfortunately, the OFR requires a total of at least $total"MB" to properly install." 
        echo "$INSTALL_DRIVE is below the minimum required capacity and therefore, cannot be used to"
        echo -e "complete the installation.\n"
        echo "If other drives are present"
        echo -e "Please select another drive...\n"

        INSTALL_DRIVE=''
      fi
    fi
  done

  warn_of_dire_consequences

  echo

  # make sure we aren't working on a mounted part
  unmount "$INSTALL_DRIVE"

  # remove any existing partitions on that drive
  delete_partitions "$INSTALL_DRIVE"

  # Enforce minimum partion size requirement.
  ROOT_PARTITION_SIZE=0
  while [ $ROOT_MIN -gt $ROOT_PARTITION_SIZE ]; do
    # Get the size of the drive
    size=$(get_drive_size $INSTALL_DRIVE)
    echo -n "How big of a root partition should I create? ($ROOT_MIN"MB" - $size"MB") [$size]MB: "
    response=$(get_response "$size")
    # TODO: need to have better error checking on this value
    ROOT_PARTITION_SIZE=$(echo "$response" | sed 's/[^0-9]//g')
    if [ $ROOT_PARTITION_SIZE -lt $ROOT_MIN ] || [ $ROOT_PARTITION_SIZE -gt $size ]; then
      echo "Root partion must be between $ROOT_MIN"MB" and $size"MB""
      echo
      ROOT_PARTITION_SIZE=0
    fi
  done

  echo

  # now take the data and create the partitions
  create_partitions "$INSTALL_DRIVE" "$ROOT_PARTITION_SIZE" 0 "yes"
}

# walk the user through a union setup
# sets globals INSTALL_DRIVE, ROOT_PARTITION, CONFIG_PARTITION
setup_method_union() {
  UNION=1

  echo "A union install requires an image partition of at least 250mbs." 
  echo "If you want to accomodate more than one image on the partition,"
  echo "it should be larger.  Each image is roughly 200mbs.  This "
  echo "partition will be the bootable partition for this machine."
  echo

  # Ask for the image partition and make sure it's valid
  while [ -z "$ROOT_PARTITION" ]
  do
    select_partition 250 "Which partition should I install the images on?"
    # Note that PARTITION is defined in select partition
    ROOT_PARTITION=$PARTITION
    unmount "$ROOT_PARTITION"
    vd=$(grep $ROOT_PARTITION /proc/partitions | awk '{ print $4 }')

    if [ -z "$vd" ]; then
      echo
      echo "$ROOT_PARTITION is an invalid partition. Please try again."
      ROOT_PARTITION=""
    fi
  done
 
  echo Creating filesystem on $ROOT_PARTITION 
  make_filesystem $ROOT_PARTITION

  echo
  echo "An optional writable persistent root partition may also"
  echo "be created.  This partition will allow you to store "
  echo "files between reboots and upgrade packages."  
  echo 
  echo -n "Would you like to create a persistent root partition? (Yes/No) [Yes]: "
  response=$(get_response "Yes" "Yes No Y N")
  if [ "$response" == "yes" ] || [ "$response" == "y" ]; then
    echo "The persistent root partition should be a minimum of 50mbs"
    echo "for log files.  If you plan on adding any other software or"
    echo "upgrading it, the root partition should be large enough to"
    echo "accomodate those packages"

    # Ask for the union partition and make sure it's valid
    while [ -z "$UNION_PARTITION" ]
    do
      select_partition 50 "Which partition should I install the binary images on?" "$ROOT_PARTITION"
      # Note that PARTITION is defined in select partition
      UNION_PARTITION=$PARTITION
      unmount "$UNION_PARTITION"
      vd=$(grep $UNION_PARTITION /proc/partitions | awk '{ print $4 }')

      if [ -z "$vd" ]; then
        echo
        echo "$UNION_PARTITION is an invalid partition. Please try again."
        UNION_PARTITION=""
      fi
    done

    echo Creating filesystems on $ROOT_PARTITION 
    make_filesystem $UNION_PARTITION

    echo Labeling $UNION_PARTITION 
    e2label /dev/$UNION_PARTITION live-rw
  fi
}

unmount () {
  # grab the list of mounted drives
  # make sure to reverse sort so as to unmount up the tree
  mounted=$(mount | grep "$1" | cut -f3 -d' ' | sort -r)
  if [ -n "$mounted" ]; then
    echo    "I need to unmount: "
    echo    "$mounted"

    response=''
    while [ -z $response ]
    do 
      echo -n "Continue (Yes/No) [No]: "
      response=$(get_response "No" "Yes No Y N")
      if [ "$response" == "no" ] || [ "$response" == "n" ]; then
        echo -e "Ok then.  Need to unmount to continue.\nExiting..."
        exit 1
      fi
    done
 
    for parts in "$mounted"
    do
      echo "umount $parts" >> $INSTALL_LOG
      output=$(umount $parts)
      status=$?
      if [ "$status" != 0 ]; then
        echo -e "Exiting: error unmounting $parts.\nPlease see $INSTALL_LOG for more details."
        echo -e "Exiting: error unmounting $parts.\numount $parts\n$output" >> $INSTALL_LOG
        exit 1
      fi
    done
  fi
}

setup_xen_partition_images () {
  if [ -d "$rootfsdir/var/xen/" ]; then
    echo Setting up Xen virtual machine images
    compressed_images=$(ls $rootfsdir/var/xen/*.img.gz 2> /dev/null)
    if [ -n "$compressed_images" ]; then
      for cmp_img in $compressed_images; do
        # uncompress the image
        uncmp_img=$(echo $cmp_img | sed s'/.gz$//') 
        if [ ! -f "$uncmp_img" ]; then
          echo decompressing $cmp_img
          gzip -dc $cmp_img > $uncmp_img
        fi
      done
    fi
    echo
  fi
}

progress_indicator () {
  case "$1" in
    start) $vyatta_bindir/progress-indicator $SPID &
             ;;
    *)
	     if ! rm /tmp/pi.$SPID 2>/dev/null
	     then
		sleep 1
		rm /tmp/pi.$SPID 2>/dev/null
	     fi

             sleep 1
	     echo -n -e "\b"
             ;;
  esac
}

#####  Main
##
# clean up existing log files
if [ -f $INSTALL_LOG.old ]; then 
  rm -f $INSTALL_LOG.old
fi
if [ -f $INSTALL_LOG ]; then
  mv $INSTALL_LOG $INSTALL_LOG.old
  rm -f $INSTALL_LOG
fi

# turn off any mounted swap files
turnoffswap

# Print welcome and instructions.
echo "Welcome to the Vyatta install program.  This script"
echo "will walk you through the process of installing the"
echo "Vyatta image to a local hard drive."
echo

response=''
while [ -z $response ]
do
  echo -n "Would you like to continue? (Yes/No) [Yes]: "
  response=$(get_response "Yes" "Yes No Y N")
  if [ "$response" == "no" ] || [ "$response" == "n" ]; then
    echo "Ok then.  Exiting..."
    exit 1
  fi
done

# some drives don't show up in /proc/partitions so we need to bootstrap them
echo -n "Probing drives:  "
progress_indicator start
probe_drives
progress_indicator stop
echo "OK"

INSTALL_METHOD=''
check_for_old_raid
if [ -z "$INSTALL_METHOD" ]; then
    check_for_new_raid
fi

if [ -z "$INSTALL_METHOD" ]; then
    echo "The Vyatta image will require a minimum ${ROOT_MIN}MB root."
    echo "Would you like me to try to partition a drive automatically"
    echo "or would you rather partition it manually with parted?  If"
    echo "you have already setup your partitions, you may skip this step."
    echo

    while [ -z $INSTALL_METHOD ]
    do
	echo -n "Partition (Auto/Union/Parted/Skip) [Auto]: "
	INSTALL_METHOD=$(get_response "Auto" "Auto Parted Skip Union A P S U")
    done

    echo
fi
  
# TODO: Note installs assume an LBA BIOS.  So no boot partition currently.
# also note that we are not creating a swap partition right now.
if [ "$INSTALL_METHOD" == "parted" ] || [ "$INSTALL_METHOD" == "p" ]; then
  setup_method_manual "parted"
elif [ "$INSTALL_METHOD" == "skip" ] || [ "$INSTALL_METHOD" == "s" ]; then
  setup_method_manual "skip" 
elif [ "$INSTALL_METHOD" == "auto" ] || [ "$INSTALL_METHOD" == "a" ]; then
  setup_method_auto
elif [ "$INSTALL_METHOD" == "union" ] || [ "$INSTALL_METHOD" == "u" ]; then
  echo "A union install requires an image partition of at least 250mbs."
  echo "If you want to accomodate more than one image on the partition,"
  echo "it should be larger.  Each image is roughly 200mbs.  This "
  echo "partition will be the bootable partition for this machine."
  echo

  UNION=1
  setup_method_auto
elif [ "$INSTALL_METHOD" == "vyatta" ]; then
  echo "Automated install..."
  echo "unmounting $INSTALL_DRIVE"
  unmount "$INSTALL_DRIVE"
  echo "deleting partitions on $INSTALL_DRIVE"
  delete_partitions "$INSTALL_DRIVE"
  echo "creating config partition"
  create_partitions "$INSTALL_DRIVE" "$ROOT_PARTITION_SIZE" 0 "yes"
fi

if [ ! -d /live/image -o -w /live/image ]; then
    if [ -z $UNION ]; then
	echo "install-system can only be run from livecd"
	exit 1
    fi
fi

# Install the root filesystem
install_root_filesystem "$ROOT_PARTITION"

# Copy the config files
copy_config "$CONFIG_PARTITION"

# Modify config to match system
# Assume user wants to keep password from old config
if [ ! -d /mnt/config ]; then
    system_setup
fi

# check for xen part images in /var/xen
setup_xen_partition_images

# Install grub
install_grub

if [ -z $UNION ]; then
  # Fix up PAM configuration for login so that invalid users are prompted
  # for password
  sed -i 's/requisite[ \t][ \t]*pam_securetty.so/required pam_securetty.so/' $rootfsdir/etc/pam.d/login
fi

#
# Only start the mdadm daemon if we have the root filesystem running
# on a RAID set.  Since this script is the only way that the root filesystem
# ever gets set up, we can do this configuration here.
#
MDADM_CONFIG_FILE=$rootfsdir/etc/default/mdadm
if [ -e $MDADM_CONFIG_FILE ]; then
    if [ ${INSTALL_DRIVE:0:2} = "md" ]; then
	sed -i 's/^START_DAEMON.*$/START_DAEMON=true/' $MDADM_CONFIG_FILE
    else
	sed -i 's/^START_DAEMON.*$/START_DAEMON=false/' $MDADM_CONFIG_FILE
    fi
fi


# postinst hook
if [ -e /opt/vyatta/etc/install-system/postinst ]; then
  echo "running post-install script"
  /opt/vyatta/etc/install-system/postinst $rootfsdir >>$INSTALL_LOG
fi


cp $INSTALL_LOG $rootfsdir/install.log

umount $rootfsdir

echo "Done!"
echo "Done!" >> $INSTALL_LOG

exit 0
